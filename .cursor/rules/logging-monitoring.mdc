---
description: "Comprehensive logging and monitoring setup with structured logging"
globs: **/logging.py, **/logs/**/*, **/monitoring.py, **/log_config.py
alwaysApply: false
---

# üìä Logging & Monitoring Guidelines

## üîç Modern Logging Setup with MDC

### Loguru + MDC Integration
```python
# app/core/logging.py
import sys
import json
from pathlib import Path
from typing import Dict, Any, Optional
from contextvars import ContextVar

from loguru import logger
from mdc import MDC, with_mdc
from app.core.config import settings

# Context variables –¥–ª—è request tracking
request_id_var: ContextVar[str] = ContextVar("request_id", default="")
user_id_var: ContextVar[str] = ContextVar("user_id", default="")
trace_id_var: ContextVar[str] = ContextVar("trace_id", default="")

def setup_logging():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å MDC"""
    
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π handler
    logger.remove()
    
    # Console logging –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
    if settings.DEBUG:
        logger.add(
            sys.stderr,
            format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
                   "<level>{level: <8}</level> | "
                   "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | "
                   "<yellow>[{extra[request_id]}]</yellow> | "
                   "<level>{message}</level>",
            level="DEBUG",
            colorize=True,
            backtrace=True,
            diagnose=True,
            enqueue=True
        )
    
    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤
    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)
    
    # Structured JSON logging –¥–ª—è production
    logger.add(
        logs_dir / "app.jsonl",
        format=format_json_log,
        level="INFO",
        rotation="100 MB",
        retention="30 days",
        compression="gz",
        enqueue=True,
        serialize=False
    )
    
    # –û—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è –æ—à–∏–±–æ–∫
    logger.add(
        logs_dir / "errors.jsonl",
        format=format_json_log,
        level="ERROR",
        rotation="50 MB",
        retention="60 days",
        compression="gz",
        backtrace=True,
        diagnose=True,
        enqueue=True,
        serialize=False
    )

def format_json_log(record: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–æ–≤ –≤ JSON —Å MDC –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º"""
    
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ MDC –∏ ContextVar
    mdc_context = {}
    if hasattr(record.get('extra', {}), 'get'):
        mdc_context = record['extra'].get('mdc', {})
    
    log_entry = {
        "timestamp": record["time"].isoformat(),
        "level": record["level"].name,
        "logger": record["name"],
        "module": record["module"],
        "function": record["function"],
        "line": record["line"],
        "message": record["message"],
        "request_id": request_id_var.get(""),
        "user_id": user_id_var.get(""),
        "trace_id": trace_id_var.get(""),
        "mdc": mdc_context,
        "extra": {k: v for k, v in record.get("extra", {}).items() 
                 if k not in ["request_id", "user_id", "trace_id", "mdc"]},
        "process": {
            "id": record["process"].id,
            "name": record["process"].name
        },
        "thread": {
            "id": record["thread"].id,
            "name": record["thread"].name
        }
    }
    
    # –î–æ–±–∞–≤–ª—è–µ–º exception info –µ—Å–ª–∏ –µ—Å—Ç—å
    if record.get("exception"):
        log_entry["exception"] = {
            "type": record["exception"].type.__name__,
            "value": str(record["exception"].value),
            "traceback": record["exception"].traceback
        }
    
    return json.dumps(log_entry, ensure_ascii=False) + "\n"

class StructuredLogger:
    """Wrapper –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å MDC –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º"""
    
    def __init__(self, name: str):
        self.name = name
        self.logger = logger.bind(module=name)
    
    def _enrich_context(self, **kwargs) -> Dict[str, Any]:
        """–û–±–æ–≥–∞—â–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        context = {
            "request_id": request_id_var.get(""),
            "user_id": user_id_var.get(""),
            "trace_id": trace_id_var.get(""),
            "service": "vk-comments-monitor",
            "environment": settings.ENVIRONMENT,
            **kwargs
        }
        return {k: v for k, v in context.items() if v}
    
    def info(self, message: str, **kwargs):
        context = self._enrich_context(**kwargs)
        with MDC(**context):
            self.logger.bind(**context).info(message)
    
    def error(self, message: str, **kwargs):
        context = self._enrich_context(**kwargs)
        with MDC(**context):
            self.logger.bind(**context).error(message)
    
    def warning(self, message: str, **kwargs):
        context = self._enrich_context(**kwargs)
        with MDC(**context):
            self.logger.bind(**context).warning(message)
    
    def debug(self, message: str, **kwargs):
        context = self._enrich_context(**kwargs)
        with MDC(**context):
            self.logger.bind(**context).debug(message)
    
    @with_mdc
    def log_operation(self, operation: str, **context):
        """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π"""
        def decorator(func):
            async def wrapper(*args, **kwargs):
                start_time = time.time()
                operation_id = str(uuid.uuid4())
                
                with MDC(operation=operation, operation_id=operation_id, **context):
                    self.info(f"Starting {operation}", **context)
                    
                    try:
                        result = await func(*args, **kwargs)
                        duration = time.time() - start_time
                        
                        self.info(
                            f"Completed {operation}",
                            duration=duration,
                            status="success",
                            **context
                        )
                        return result
                        
                    except Exception as e:
                        duration = time.time() - start_time
                        self.error(
                            f"Failed {operation}",
                            duration=duration,
                            status="error",
                            error_type=type(e).__name__,
                            error_message=str(e),
                            **context
                        )
                        raise
            return wrapper
        return decorator

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
log = StructuredLogger(__name__)
```

## üåê FastAPI Request Tracking Middleware

### Enhanced Request Logging
```python
# app/middleware/logging.py
import time
import uuid
from typing import Callable, Optional
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
from mdc import MDC

from app.core.logging import StructuredLogger, request_id_var, user_id_var, trace_id_var
from app.core.auth import decode_access_token

log = StructuredLogger(__name__)

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è HTTP –∑–∞–ø—Ä–æ—Å–æ–≤ —Å MDC –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º"""
    
    def __init__(self, app, exclude_paths: Optional[list] = None):
        super().__init__(app)
        self.exclude_paths = exclude_paths or ["/health", "/metrics", "/docs", "/redoc"]
    
    async def dispatch(self, request: Request, call_next: Callable):
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ endpoints
        if any(request.url.path.startswith(path) for path in self.exclude_paths):
            return await call_next(request)
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
        request_id = str(uuid.uuid4())
        trace_id = request.headers.get("x-trace-id", str(uuid.uuid4()))
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
        request_id_var.set(request_id)
        trace_id_var.set(trace_id)
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º user_id –∏–∑ JWT
        user_id = await self._extract_user_id(request)
        if user_id:
            user_id_var.set(str(user_id))
        
        start_time = time.time()
        
        # –°–æ–∑–¥–∞–µ–º MDC –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
        request_context = {
            "request_id": request_id,
            "trace_id": trace_id,
            "method": request.method,
            "path": request.url.path,
            "query_params": str(request.query_params),
            "client_ip": request.client.host,
            "user_agent": request.headers.get("user-agent", ""),
            "content_type": request.headers.get("content-type", ""),
            "content_length": request.headers.get("content-length", 0),
            "user_id": user_id
        }
        
        with MDC(**request_context):
            log.info("Request started")
            
            try:
                response = await call_next(request)
                duration = time.time() - start_time
                
                # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
                response_context = {
                    "status_code": response.status_code,
                    "duration": round(duration, 4),
                    "response_size": response.headers.get("content-length", 0)
                }
                
                with MDC(**response_context):
                    if response.status_code >= 400:
                        log.warning("Request completed with error")
                    else:
                        log.info("Request completed successfully")
                
                # –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–µ–π—Å–∏–Ω–≥ –∑–∞–≥–æ–ª–æ–≤–∫–∏
                response.headers["X-Request-ID"] = request_id
                response.headers["X-Trace-ID"] = trace_id
                response.headers["X-Process-Time"] = str(round(duration, 4))
                
                return response
                
            except Exception as e:
                duration = time.time() - start_time
                
                # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
                error_context = {
                    "duration": round(duration, 4),
                    "error_type": type(e).__name__,
                    "error_message": str(e)
                }
                
                with MDC(**error_context):
                    log.error("Request failed with exception")
                
                raise
    
    async def _extract_user_id(self, request: Request) -> Optional[int]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ user_id –∏–∑ JWT —Ç–æ–∫–µ–Ω–∞"""
        try:
            authorization = request.headers.get("authorization")
            if authorization and authorization.startswith("Bearer "):
                token = authorization.split(" ")[1]
                payload = decode_access_token(token)
                return payload.get("sub")
        except Exception:
            pass
        return None
```

## üìà Performance & Business Metrics

### Prometheus Integration
```python
# app/monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge, Info
from prometheus_client.openmetrics.exposition import CONTENT_TYPE_LATEST, generate_latest
from fastapi import Response
from mdc import MDC

from app.core.logging import StructuredLogger

log = StructuredLogger(__name__)

# HTTP –º–µ—Ç—Ä–∏–∫–∏
http_requests_total = Counter(
    "http_requests_total",
    "Total HTTP requests",
    ["method", "endpoint", "status_code"]
)

http_request_duration_seconds = Histogram(
    "http_request_duration_seconds",
    "HTTP request duration in seconds",
    ["method", "endpoint"],
    buckets=[0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
)

http_request_size_bytes = Histogram(
    "http_request_size_bytes",
    "HTTP request size in bytes",
    ["method", "endpoint"]
)

http_response_size_bytes = Histogram(
    "http_response_size_bytes",
    "HTTP response size in bytes",
    ["method", "endpoint"]
)

# Business –º–µ—Ç—Ä–∏–∫–∏
comments_processed_total = Counter(
    "comments_processed_total",
    "Total processed comments",
    ["group_id", "status"]
)

vk_api_calls_total = Counter(
    "vk_api_calls_total",
    "Total VK API calls",
    ["method", "status", "error_code"]
)

vk_api_rate_limit_remaining = Gauge(
    "vk_api_rate_limit_remaining",
    "Remaining VK API rate limit"
)

background_tasks_total = Counter(
    "background_tasks_total",
    "Total background tasks",
    ["task_name", "status"]
)

background_task_duration_seconds = Histogram(
    "background_task_duration_seconds",
    "Background task duration in seconds",
    ["task_name"],
    buckets=[1, 5, 10, 30, 60, 300, 600]
)

# Database –º–µ—Ç—Ä–∏–∫–∏
database_connections_active = Gauge(
    "database_connections_active",
    "Active database connections"
)

database_query_duration_seconds = Histogram(
    "database_query_duration_seconds",
    "Database query duration in seconds",
    ["operation"],
    buckets=[0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5]
)

# Application info
app_info = Info(
    "app_info",
    "Application information"
)

class MetricsCollector:
    """–°–±–æ—Ä—â–∏–∫ –º–µ—Ç—Ä–∏–∫ —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
    
    def __init__(self):
        app_info.info({
            "version": "1.0.0",
            "environment": "production"
        })
    
    def record_http_request(self, method: str, endpoint: str, status_code: int, 
                          duration: float, request_size: int = 0, response_size: int = 0):
        """–ó–∞–ø–∏—Å—å HTTP –º–µ—Ç—Ä–∏–∫"""
        with MDC(method=method, endpoint=endpoint, status_code=status_code):
            http_requests_total.labels(
                method=method,
                endpoint=endpoint,
                status_code=status_code
            ).inc()
            
            http_request_duration_seconds.labels(
                method=method,
                endpoint=endpoint
            ).observe(duration)
            
            if request_size > 0:
                http_request_size_bytes.labels(
                    method=method,
                    endpoint=endpoint
                ).observe(request_size)
            
            if response_size > 0:
                http_response_size_bytes.labels(
                    method=method,
                    endpoint=endpoint
                ).observe(response_size)
            
            log.debug("HTTP metrics recorded")
    
    def record_comment_processed(self, group_id: str, status: str):
        """–ó–∞–ø–∏—Å—å –º–µ—Ç—Ä–∏–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤"""
        with MDC(group_id=group_id, status=status):
            comments_processed_total.labels(
                group_id=group_id,
                status=status
            ).inc()
            
            log.debug("Comment processing metrics recorded")
    
    def record_vk_api_call(self, method: str, status: str, error_code: str = ""):
        """–ó–∞–ø–∏—Å—å –º–µ—Ç—Ä–∏–∫ VK API"""
        with MDC(vk_method=method, status=status, error_code=error_code):
            vk_api_calls_total.labels(
                method=method,
                status=status,
                error_code=error_code
            ).inc()
            
            log.debug("VK API metrics recorded")
    
    def record_background_task(self, task_name: str, status: str, duration: float):
        """–ó–∞–ø–∏—Å—å –º–µ—Ç—Ä–∏–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á"""
        with MDC(task_name=task_name, status=status, duration=duration):
            background_tasks_total.labels(
                task_name=task_name,
                status=status
            ).inc()
            
            background_task_duration_seconds.labels(
                task_name=task_name
            ).observe(duration)
            
            log.debug("Background task metrics recorded")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
metrics_collector = MetricsCollector()

async def metrics_endpoint() -> Response:
    """Endpoint –¥–ª—è Prometheus –º–µ—Ç—Ä–∏–∫"""
    return Response(
        content=generate_latest(),
        media_type=CONTENT_TYPE_LATEST
    )
```

## üîç Application Performance Monitoring

### Database Query Monitoring
```python
# app/monitoring/database.py
import time
from sqlalchemy import event
from sqlalchemy.engine import Engine
from mdc import MDC

from app.core.logging import StructuredLogger
from app.monitoring.metrics import database_query_duration_seconds

log = StructuredLogger(__name__)

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –º–µ–¥–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
@event.listens_for(Engine, "before_cursor_execute")
def receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    """–ù–∞—á–∞–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è SQL –∑–∞–ø—Ä–æ—Å–∞"""
    context._query_start_time = time.time()
    context._query_statement = statement[:200] + "..." if len(statement) > 200 else statement

@event.listens_for(Engine, "after_cursor_execute")  
def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    """–û–∫–æ–Ω—á–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è SQL –∑–∞–ø—Ä–æ—Å–∞"""
    duration = time.time() - context._query_start_time
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏
    operation = statement.strip().split()[0].upper()
    
    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏
    database_query_duration_seconds.labels(operation=operation).observe(duration)
    
    # –õ–æ–≥–∏—Ä—É–µ–º –º–µ–¥–ª–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
    if duration > 0.1:  # –ú–µ–¥–ª–µ–Ω–Ω–µ–µ 100ms
        with MDC(
            query_duration=round(duration, 4),
            query_operation=operation,
            query_statement=context._query_statement,
            parameters_count=len(parameters) if parameters else 0
        ):
            log.warning("Slow database query detected")
    
    # Debug –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ development
    elif settings.DEBUG:
        with MDC(
            query_duration=round(duration, 4),
            query_operation=operation,
            query_statement=context._query_statement
        ):
            log.debug("Database query executed")
```

## üö® Error Tracking & Alerting

### Sentry Integration
```python
# app/monitoring/sentry.py
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
from sentry_sdk.integrations.celery import CeleryIntegration
from sentry_sdk.integrations.redis import RedisIntegration

from app.core.config import settings
from app.core.logging import request_id_var, user_id_var, trace_id_var

def setup_sentry():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Sentry –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ—à–∏–±–æ–∫"""
    
    if not settings.SENTRY_DSN:
        return
    
    def add_context_processor(event, hint):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤ —Å–æ–±—ã—Ç–∏—è Sentry"""
        event.setdefault("extra", {}).update({
            "request_id": request_id_var.get(""),
            "user_id": user_id_var.get(""),
            "trace_id": trace_id_var.get(""),
            "environment": settings.ENVIRONMENT,
            "service": "vk-comments-monitor"
        })
        return event
    
    sentry_sdk.init(
        dsn=settings.SENTRY_DSN,
        environment=settings.ENVIRONMENT,
        release=settings.APP_VERSION,
        integrations=[
            FastApiIntegration(auto_enabling_integrations=False),
            SqlalchemyIntegration(),
            CeleryIntegration(),
            RedisIntegration(),
        ],
        traces_sample_rate=0.1,
        profiles_sample_rate=0.1,
        before_send=add_context_processor,
        max_breadcrumbs=50,
        debug=settings.DEBUG,
    )
```

## ‚úÖ Monitoring Checklist

### Logging Configuration
- [ ] Structured JSON logging –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] MDC –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–µ–∑–¥–µ
- [ ] Log rotation –∏ retention –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
- [ ] Sensitive data —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç—Å—è
- [ ] Request tracking —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Error tracking –≤–∫–ª—é—á–µ–Ω
- [ ] Performance logging –Ω–∞—Å—Ç—Ä–æ–µ–Ω

### Metrics & Monitoring
- [ ] Prometheus –º–µ—Ç—Ä–∏–∫–∏ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è
- [ ] Business –º–µ—Ç—Ä–∏–∫–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—é—Ç—Å—è
- [ ] Health check endpoints —Ä–∞–±–æ—Ç–∞—é—Ç
- [ ] Database monitoring –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] VK API rate limiting –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è
- [ ] Background tasks –º–æ–Ω–∏—Ç–æ—Ä—è—Ç—Å—è
- [ ] Resource usage tracking –≤–∫–ª—é—á–µ–Ω

### Alerting
- [ ] Critical error alerts –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
- [ ] Performance degradation alerts
- [ ] Rate limit alerts –¥–ª—è VK API
- [ ] Database connection alerts
- [ ] Disk space monitoring
- [ ] Memory usage alerts
- [ ] Failed deployment notifications

### Observability
- [ ] Distributed tracing –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] Log correlation —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Metrics dashboards —Å–æ–∑–¥–∞–Ω—ã
- [ ] SLA/SLO –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã
- [ ] Runbooks –¥–ª—è –∏–Ω—Ü–∏–¥–µ–Ω—Ç–æ–≤
- [ ] On-call –ø—Ä–æ—Ü–µ–¥—É—Ä—ã –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã

---

üìö **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: [MDC for Python](mdc:https:/github.com/AFriemann/mdc) | [Loguru](mdc:https:/loguru.readthedocs.io) | [Prometheus Client](mdc:https:/prometheus.io/docs)

