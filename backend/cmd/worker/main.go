package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/hibiken/asynq"
	pgdriver "gorm.io/driver/postgres"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"

	"vk-analyzer/internal/domain/comments"
	"vk-analyzer/internal/domain/morphological"
	"vk-analyzer/internal/repository/postgres"
	"vk-analyzer/internal/repository/vk"
)

// FetchCommentsPayload represents the payload for vk:fetch_comments task.
type FetchCommentsPayload struct {
	OwnerID int64  `json:"owner_id"`
	PostID  int64  `json:"post_id"`
	TaskID  string `json:"task_id"`
}

// AnalyzePayload represents the payload for morphological:analyze task.
type AnalyzePayload struct {
	CommentIDs []int64 `json:"comment_ids"`
	TaskID     string  `json:"task_id"`
}

// HandleFetchComments processes the vk:fetch_comments task.
// Fetches comments from VK API, maps to domain models, saves to PostgreSQL,
// and enqueues morphological:analyze task for each batch of comments.
func HandleFetchComments(ctx context.Context, t *asynq.Task) error {
	var p FetchCommentsPayload
	if err := json.Unmarshal(t.Payload(), &p); err != nil {
		return fmt.Errorf("failed to unmarshal payload: %w", err)
	}

	// Get Redis client to retrieve access token stored by task_id
	redisAddr := os.Getenv("REDIS_URL")
	if redisAddr == "" {
		redisAddr = "localhost:6379"
	}
	rdb := redis.NewClient(&redis.Options{
		Addr: redisAddr,
	})
	tokenKey := "token:" + p.TaskID
	token, err := rdb.Get(ctx, tokenKey).Result()
	if err != nil {
		return fmt.Errorf("failed to get token from Redis: %w", err)
	}

	// Fetch comments using VKRepository
	vkRepo := vk.NewVKRepository()
	vkComments, err := vkRepo.GetComments(ctx, p.OwnerID, p.PostID, token)
	if err != nil {
		return fmt.Errorf("failed to fetch comments from VK: %w", err)
	}

	// Map VKComments to domain Comments
	var domainComments []comments.Comment
	for _, vc := range vkComments {
		domainComments = append(domainComments, comments.Comment{
			FromID: vc.FromID,
			Date:   vc.Date.Unix(),
			Text:   vc.Text,
			Likes:  &comments.Likes{Count: vc.Likes},
			// ID will be auto-generated by GORM
		})
	}

	// Connect to PostgreSQL and save comments
	dsn := os.Getenv("DATABASE_URL")
	if dsn == "" {
		return fmt.Errorf("DATABASE_URL not set")
	}
	db, err := gorm.Open(pgdriver.Open(dsn), &gorm.Config{})
	if err != nil {
		return fmt.Errorf("failed to connect to PostgreSQL: %w", err)
	}
	commentRepo := postgres.NewCommentRepository(db)

	if err := commentRepo.CreateMany(domainComments); err != nil {
		return fmt.Errorf("failed to save comments: %w", err)
	}

	// Extract comment IDs after creation (assuming GORM sets IDs on the structs)
	var commentIDs []int64
	for _, c := range domainComments {
		commentIDs = append(commentIDs, c.ID)
	}

	// Enqueue morphological:analyze task with max 3 retries
	analyzePayload := AnalyzePayload{
		CommentIDs: commentIDs,
		TaskID:     p.TaskID,
	}
	payloadBytes, err := json.Marshal(analyzePayload)
	if err != nil {
		return fmt.Errorf("failed to marshal analyze payload: %w", err)
	}

	analyzeTask := asynq.NewTask("morphological:analyze", payloadBytes, asynq.MaxRetry(3))
	asynqClient := asynq.NewClient(asynq.RedisClientOpt{Addr: redisAddr})
	if _, err := asynqClient.Enqueue(analyzeTask); err != nil {
		return fmt.Errorf("failed to enqueue analyze task: %w", err)
	}

	return nil
}

// HandleAnalyze processes the morphological:analyze task.
// Performs morphological analysis on comments and updates them in DB.
func HandleAnalyze(ctx context.Context, t *asynq.Task) error {
	var p AnalyzePayload
	if err := json.Unmarshal(t.Payload(), &p); err != nil {
		return fmt.Errorf("failed to unmarshal payload: %w", err)
	}

	// Connect to PostgreSQL
	dsn := os.Getenv("DATABASE_URL")
	if dsn == "" {
		return fmt.Errorf("DATABASE_URL not set")
	}
	db, err := gorm.Open(pgdriver.Open(dsn), &gorm.Config{})
	if err != nil {
		return fmt.Errorf("failed to connect to PostgreSQL: %w", err)
	}
	commentRepo := postgres.NewCommentRepository(db)

	// Perform analysis for each comment
	for _, id := range p.CommentIDs {
		// Get comment by ID
		comment, err := commentRepo.GetByID(id)
		if err != nil {
			log.Printf("Failed to get comment %d: %v", id, err)
			continue
		}

		// Perform morphological analysis
		analysis := morphological.AnalyzeText(comment.Text)

		// Update comment with analysis results
		comment.Keywords = analysis.Keywords
		comment.Sentiment = analysis.Sentiment

		// Save updated comment
		if err := commentRepo.Update(comment); err != nil {
			log.Printf("Failed to update comment %d: %v", id, err)
			continue
		}

		log.Printf("Analysis completed for comment %d: keywords=%v, sentiment=%s", id, analysis.Keywords, analysis.Sentiment)
	}

	return nil
}

func main() {
	redisAddr := os.Getenv("REDIS_URL")
	if redisAddr == "" {
		redisAddr = "localhost:6379"
	}

	// Asynq server options
	redisOpt := asynq.RedisClientOpt{
		Addr: redisAddr,
	}

	srv := asynq.NewServer(
		redisOpt,
		asynq.Config{
			Concurrency: 10,
			// Retry delay function for exponential backoff
			RetryDelayFunc: func(n int, err error, t *asynq.Task) time.Duration {
				return time.Duration(1<<uint(n)) * time.Second // 1s, 2s, 4s, etc.
			},
		},
	)

	mux := asynq.NewServeMux()
	mux.HandleFunc("vk:fetch_comments", HandleFetchComments)
	mux.HandleFunc("morphological:analyze", HandleAnalyze)

	if err := srv.Run(mux); err != nil {
		log.Fatalf("Failed to run Asynq server: %v", err)
	}
}