# Alembic Configuration for VK Parser Backend

This document describes the Alembic database migration setup for the VK Parser Backend project.

## Overview

Alembic is configured to work with:

- **FastAPI** + **SQLAlchemy 2.0** + **AsyncPG**
- **PostgreSQL** database
- **Async/await** support
- **Environment-based** configuration
- **Automatic code formatting** with Black and Ruff

## Configuration Files

### `alembic.ini`

Main Alembic configuration file with:

- Timestamped migration file names
- UTC timezone for consistency
- Post-write hooks for code formatting
- Proper Python path setup

### `alembic/env.py`

Environment configuration with:

- Async database connection support
- Environment variable handling
- Model import management
- Autogenerate features enabled

## Environment Variables

The migration system uses the following environment variables:

```bash
# Required
DATABASE_URL="postgresql+asyncpg://user:password@host:port/database"

# Optional (for different environments)
NODE_ENV="development"  # or "test", "production"
```

## Available Commands

### Using Poetry Scripts

```bash
# Apply all pending migrations
poetry run migrate

# Create new migration with autogenerate
poetry run makemigrations

# Show migration history
poetry run migration-history

# Show current state
poetry run migration-current

# Downgrade one migration
poetry run downgrade

# Show specific migration
poetry run migration-show <revision>

# Merge migration heads
poetry run migration-merge <rev1> <rev2> "Merge message"

# Stamp database with revision
poetry run migration-stamp <revision>
```

### Using Custom Script

```bash
# Apply all pending migrations
python scripts/migrate.py up

# Apply next migration
python scripts/migrate.py up +1

# Rollback last migration
python scripts/migrate.py down

# Rollback to base (empty database)
python scripts/migrate.py down base

# Create new migration
python scripts/migrate.py create "Add user table"

# Create empty migration (no autogenerate)
python scripts/migrate.py create "Custom migration" --no-autogenerate

# Show migration history
python scripts/migrate.py history

# Show current state
python scripts/migrate.py current

# Show specific migration
python scripts/migrate.py show abc123

# Merge migration heads
python scripts/migrate.py merge abc123 def456 "Merge migrations"

# Stamp database with revision
python scripts/migrate.py stamp abc123
```

### Using Alembic Directly

```bash
# Apply migrations
alembic upgrade head

# Create migration
alembic revision --autogenerate -m "Migration message"

# Show history
alembic history --verbose

# Show current
alembic current

# Downgrade
alembic downgrade -1

# Show specific migration
alembic show <revision>
```

## Migration Workflow

### 1. Development Workflow

```bash
# 1. Make changes to your models
# 2. Create migration
poetry run makemigrations

# 3. Review the generated migration file
# 4. Apply migration
poetry run migrate

# 5. If needed, rollback
poetry run downgrade
```

### 2. Production Deployment

```bash
# 1. Set production DATABASE_URL
export DATABASE_URL="postgresql+asyncpg://user:pass@prod-host:5432/prod_db"

# 2. Apply all pending migrations
poetry run migrate

# 3. Verify current state
poetry run migration-current
```

### 3. Testing

```bash
# 1. Set test DATABASE_URL
export DATABASE_URL="postgresql+asyncpg://test:test@localhost:5432/test_db"

# 2. Apply migrations
poetry run migrate

# 3. Run tests
poetry run pytest
```

## Migration File Naming

Migration files follow this pattern:

```
YYYY_MM_DD_HHMM-<revision_id>_<slug>.py
```

Example:

```
2024_01_15_1430-abc123def456_add_user_table.py
```

## Best Practices

### 1. Always Review Generated Migrations

Before applying autogenerated migrations:

- Review the generated SQL
- Check for data loss scenarios
- Test on development database first

### 2. Use Descriptive Messages

```bash
# Good
poetry run makemigrations "Add user authentication table"

# Bad
poetry run makemigrations "Update"
```

### 3. Handle Data Migrations

For complex data migrations, create custom migrations:

```bash
# Create empty migration
python scripts/migrate.py create "Migrate user data" --no-autogenerate
```

Then edit the migration file to add custom data migration logic.

### 4. Environment Management

Always use environment-specific DATABASE_URL:

```bash
# Development
export DATABASE_URL="postgresql+asyncpg://dev:dev@localhost:5432/dev_db"

# Test
export DATABASE_URL="postgresql+asyncpg://test:test@localhost:5432/test_db"

# Production
export DATABASE_URL="postgresql+asyncpg://prod:prod@prod-host:5432/prod_db"
```

### 5. Backup Before Major Changes

```bash
# Create database backup
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql

# Apply migrations
poetry run migrate
```

## Troubleshooting

### Common Issues

1. **Import Errors**

   - Ensure all models are imported in `alembic/env.py`
   - Check Python path configuration

2. **Connection Errors**

   - Verify DATABASE_URL is correct
   - Check database server is running
   - Verify network connectivity

3. **Migration Conflicts**

   - Use `alembic merge` to resolve conflicts
   - Review migration history carefully

4. **Autogenerate Issues**
   - Check model definitions match database schema
   - Use `compare_type=True` and `compare_server_default=True`

### Debug Mode

Enable SQL logging for debugging:

```python
# In alembic/env.py, set echo=True
connectable = create_async_engine(
    url,
    echo=True,  # Enable SQL logging
    pool_pre_ping=True,
    pool_recycle=3600,
)
```

## Advanced Features

### Custom Migration Functions

You can add custom functions to migration files:

```python
def upgrade():
    # Custom upgrade logic
    pass

def downgrade():
    # Custom downgrade logic
    pass
```

### Batch Operations

For large data migrations, use batch operations:

```python
def upgrade():
    with op.batch_alter_table('users') as batch_op:
        batch_op.add_column(sa.Column('new_field', sa.String(255)))
```

### Conditional Migrations

```python
def upgrade():
    if not op.get_bind().execute("SELECT 1 FROM information_schema.tables WHERE table_name = 'users'"):
        op.create_table('users', ...)
```

## Security Considerations

1. **Never commit sensitive data** in migration files
2. **Use environment variables** for database credentials
3. **Review migrations** before applying to production
4. **Test rollback procedures** regularly
5. **Backup databases** before major migrations

## Integration with CI/CD

### GitHub Actions Example

```yaml
- name: Run Database Migrations
  run: |
    export DATABASE_URL=${{ secrets.DATABASE_URL }}
    poetry run migrate
```

### Docker Integration

```dockerfile
# In Dockerfile
COPY alembic/ /app/alembic/
COPY alembic.ini /app/

# Run migrations
CMD ["poetry", "run", "migrate"]
```

## Monitoring

Monitor migration status in production:

```bash
# Check current state
poetry run migration-current

# Show recent history
poetry run migration-history | head -10

# Verify database health
poetry run python -c "from src.database import database_service; import asyncio; print(asyncio.run(database_service.health_check()))"
```
